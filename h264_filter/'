#include <cstddef>
#include <vector>
#include <string>
#include <cstdint>
#include <iostream>
#include <memory>

#include "log.h"
#include "scoped_exit.hpp"

extern "C"
{
#include <libavcodec/avcodec.h>
#include <libavutil/avutil.h>
#include <libavfilter/avfilter.h>
#include <libavfilter/buffersink.h>
#include <libavfilter/buffersrc.h>
}

struct FilterContext
{
    AVFilterContext* buffer_src_ctx = nullptr;
    AVFilterContext* buffer_sink_ctx = nullptr;
    AVFilterGraph* filter_graph = nullptr;
    AVFrame* frame = nullptr;
};
using FilterContextPtr = std::shared_ptr<FilterContext>;

void close_filter_context(FilterContextPtr& ptr)
{
    if (ptr->filter_graph != nullptr)
    {
        avfilter_graph_free(&ptr->filter_graph);
        ptr->filter_graph = nullptr;
    }

    if (ptr->frame != nullptr)
    {
        av_frame_free(&ptr->frame);
        ptr->frame = nullptr;
    }
}

std::string av_errno_to_string(int err)
{
    char buff[AV_ERROR_MAX_STRING_SIZE] = {0};
    av_strerror(err, buff, AV_ERROR_MAX_STRING_SIZE);
    return buff;
}

std::vector<uint8_t> read_file_to_buffer(const std::string& filename)
{
    FILE* fp = fopen(filename.data(), "rb");
    if (fp == nullptr)
    {
        return {};
    }

    fseek(fp, 0, SEEK_END);
    uint32_t filesize = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    std::vector<uint8_t> bytes(filesize);

    fread(bytes.data(), 1, filesize, fp);
    fclose(fp);
    return bytes;
}

void decoder_package_to_frames(
    AVCodecContext* codec_ctx, AVPacket* pkt, AVFrame* frame, const std::string& out, FilterContextPtr& ctx);

int init_filter(const AVCodecContext* ctx, FilterContextPtr& filter_ctx);

struct H264Context
{
};
void close_h264_context(H264Context* ctx)
{
    if (ctx->codec_ctx != nullptr)
    {
        avcodec_free_context(&ctx->codec_ctx);
    }
    if (ctx->codec_parse_ctx != nullptr)
    {
        av_parser_close(ctx->codec_parse_ctx);
    }
    if (ctx->yuv_frame != nullptr)
    {
        av_frame_free(&ctx->yuv_frame);
    }
    if (ctx->h264_pkg != nullptr)
    {
        av_packet_free(&ctx->h264_pkg);
    }
    delete ctx;
}
std::shared_ptr<H264Context> get_h264_context()
{
    auto *ctx = new H264Context;
    return std::make_shared<H264Context>(ctx);
    // return ctx;
}

int main(int argc, char** argv)
{
    if (argc != 3)
    {
        std::cerr << "Usage: " << argv[0] << " <in_h264_file> <out_yuv_file>\n";
        return 1;
    }

    const auto codec_id = AV_CODEC_ID_H264;
    auto* codec = avcodec_find_decoder(codec_id);
    auto* codec_parse_ctx = av_parser_init(codec_id);
    auto* codec_ctx = avcodec_alloc_context3(codec);
    auto* pkg = av_packet_alloc();
    auto* frame = av_frame_alloc();

    int ret = avcodec_open2(codec_ctx, codec, nullptr);
    if (ret != 0)
    {
        LOG_ERROR << "avcode open failed codec id " << codec_id;
        return -1;
    }
    FilterContextPtr filter_ctx = nullptr;

    auto file_bytes = read_file_to_buffer(argv[1]);
    file_bytes.insert(file_bytes.end(), AV_INPUT_BUFFER_PADDING_SIZE, 0);

    uint8_t* data = file_bytes.data();
    size_t data_size = file_bytes.size();
    while (data_size > 0)
    {
        ret = av_parser_parse2(codec_parse_ctx,
                               codec_ctx,
                               &pkg->data,
                               &pkg->size,
                               data,
                               static_cast<int>(data_size),
                               AV_NOPTS_VALUE,
                               AV_NOPTS_VALUE,
                               0);
        if (ret < 0)

        {
            LOG_DEBUG << "av_parser_parse2 failed " << av_errno_to_string(ret);
            break;
        }
        data += ret;
        data_size -= ret;
        if (pkg->size != 0)
        {
            // 解码
            decoder_package_to_frames(codec_ctx, pkg, frame, argv[2], filter_ctx);
        }
    }

    LOG_DEBUG << "Hello World";

    return 0;
}

int init_filter(const AVCodecContext* ctx, FilterContextPtr& filter_ctx)
{
    char args[128] = {0};
    snprintf(args,
             sizeof(args),
             "width=%d:height=%d:time_base=%d/%d:pix_fmt=%d:pixel_aspect=%d/%d",
             ctx->width,
             ctx->height,
             ctx->time_base.num,
             ctx->time_base.den,
             ctx->pix_fmt,
             ctx->sample_aspect_ratio.num,
             ctx->sample_aspect_ratio.den);
    printf("%s\n", args);

    // create buffer source with the specified params
    filter_ctx->filter_graph = avfilter_graph_alloc();
    const AVFilter* buffer_src = avfilter_get_by_name("buffer");
    const AVFilter* buffer_sink = avfilter_get_by_name("buffersink");
    AVFilterInOut* outputs = avfilter_inout_alloc();
    AVFilterInOut* inputs = avfilter_inout_alloc();
    int ret = avfilter_graph_create_filter(
        &filter_ctx->buffer_src_ctx, buffer_src, "in", args, nullptr, filter_ctx->filter_graph);
    if (ret < 0)
    {
        return ret;
    }

    // create buffer sink
    ret = avfilter_graph_create_filter(
        &filter_ctx->buffer_sink_ctx, buffer_sink, "out", nullptr, nullptr, filter_ctx->filter_graph);
    if (ret < 0)
    {
        return ret;
    }

    outputs->name = av_strdup("in");
    outputs->filter_ctx = filter_ctx->buffer_src_ctx;
    outputs->pad_idx = 0;
    outputs->next = nullptr;

    inputs->name = av_strdup("out");
    inputs->filter_ctx = filter_ctx->buffer_sink_ctx;
    inputs->pad_idx = 0;
    inputs->next = nullptr;

    // create filter query
    char filter_setting[1024] = {0};

    snprintf(filter_setting, sizeof(filter_setting), " drawbox=100:200:200:60:red@0.5:t=2");
    ret = avfilter_graph_parse(filter_ctx->filter_graph, filter_setting, inputs, outputs, nullptr);
    if (ret < 0)
    {
        return ret;
    }

    ret = avfilter_graph_config(filter_ctx->filter_graph, nullptr);
    if (ret < 0)
    {
        return ret;
    }
    filter_ctx->frame = av_frame_alloc();
    return 0;
}

static void wirte_frame_to_file(const std::string& filename, const uint8_t* data, int size)
{
    FILE* fp = fopen(filename.c_str(), "ab+");
    if (fp != nullptr)
    {
        fwrite(data, 1, size, fp);
        fclose(fp);
    }
}
void add_frame_to_filter(AVFrame* frame1, FilterContextPtr& filter_ctx, const std::string& out)
{
    int ret = av_buffersrc_add_frame_flags(filter_ctx->buffer_src_ctx, frame1, AV_BUFFERSRC_FLAG_KEEP_REF);
    if (ret < 0)
    {
        LOG_ERROR << "av filter add frame failed " << av_errno_to_string(ret);
        return;
    }
    while (true)
    {
        ret = av_buffersink_get_frame(filter_ctx->buffer_sink_ctx, filter_ctx->frame);
        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
        {
            break;
        }
        if (ret < 0)
        {
            break;
        }

        DEFER(av_frame_unref(filter_ctx->frame));
        LOG_DEBUG << filter_ctx->frame->width << "*" << filter_ctx->frame->height;

        for (int j = 0; j < filter_ctx->frame->height; j++)
        {
            wirte_frame_to_file(out,
                                filter_ctx->frame->data[0] + static_cast<ptrdiff_t>(j * filter_ctx->frame->linesize[0]),
                                filter_ctx->frame->width);
        }
        for (int j = 0; j < filter_ctx->frame->height / 2; j++)
        {
            wirte_frame_to_file(out,
                                filter_ctx->frame->data[1] + static_cast<ptrdiff_t>(j * filter_ctx->frame->linesize[1]),
                                filter_ctx->frame->width / 2);
        }
        for (int j = 0; j < filter_ctx->frame->height / 2; j++)
        {
            wirte_frame_to_file(out,
                                filter_ctx->frame->data[2] + static_cast<ptrdiff_t>(j * filter_ctx->frame->linesize[2]),
                                filter_ctx->frame->width / 2);
        }
    }
}
void decoder_package_to_frames(
    AVCodecContext* codec_ctx, AVPacket* pkt, AVFrame* frame, const std::string& out, FilterContextPtr& filter_ctx)
{
    int ret = avcodec_send_packet(codec_ctx, pkt);
    if (ret == AVERROR(EAGAIN))
    {
        LOG_ERROR << "Receive_frame and send_packet both returned EAGAIN, which is an API violation";
    }
    else if (ret < 0)
    {
        LOG_ERROR << "avcodec_send_packet failed " << av_errno_to_string(ret);
        return;
    }
    while (ret >= 0)
    {
        ret = avcodec_receive_frame(codec_ctx, frame);
        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
        {
            return;
        }
        if (ret < 0)
        {
            LOG_DEBUG << "avcodec_receive_frame failed " << av_errno_to_string(ret);
            return;
        }
        LOG_DEBUG << "codec context width " << codec_ctx->width << " height " << codec_ctx->height << " pix_fmt "
                  << codec_ctx->pix_fmt << " timebase " << codec_ctx->time_base.num << "/" << codec_ctx->time_base.den
                  << " pixel_aspect " << codec_ctx->sample_aspect_ratio.num << "/"
                  << codec_ctx->sample_aspect_ratio.den;

        if (filter_ctx == nullptr)
        {
            auto tmp = std::make_shared<FilterContext>();
            ret = init_filter(codec_ctx, tmp);
            if (ret < 0)
            {
                LOG_ERROR << "create filter failed " << av_errno_to_string(ret);
                close_filter_context(tmp);
                return;
            }
            filter_ctx = tmp;
        }

        DEFER(av_frame_unref(frame));

        add_frame_to_filter(frame, filter_ctx, out);
    }
}
